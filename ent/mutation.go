// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/nuomizi-fw/stargazer/ent/bangumi"
	"github.com/nuomizi-fw/stargazer/ent/castmember"
	"github.com/nuomizi-fw/stargazer/ent/episode"
	"github.com/nuomizi-fw/stargazer/ent/predicate"
	"github.com/nuomizi-fw/stargazer/ent/season"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBangumi    = "Bangumi"
	TypeCastMember = "CastMember"
	TypeEpisode    = "Episode"
	TypeSeason     = "Season"
	TypeUser       = "User"
)

// BangumiMutation represents an operation that mutates the Bangumi nodes in the graph.
type BangumiMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	title               *string
	english_title       *string
	japanese_title      *string
	_type               *string
	status              *string
	score               *float64
	addscore            *float64
	tags                *string
	synopsis            *string
	cover_image         *string
	trailer_url         *string
	clearedFields       map[string]struct{}
	seasons             map[int]struct{}
	removedseasons      map[int]struct{}
	clearedseasons      bool
	cast_members        map[int]struct{}
	removedcast_members map[int]struct{}
	clearedcast_members bool
	done                bool
	oldValue            func(context.Context) (*Bangumi, error)
	predicates          []predicate.Bangumi
}

var _ ent.Mutation = (*BangumiMutation)(nil)

// bangumiOption allows management of the mutation configuration using functional options.
type bangumiOption func(*BangumiMutation)

// newBangumiMutation creates new mutation for the Bangumi entity.
func newBangumiMutation(c config, op Op, opts ...bangumiOption) *BangumiMutation {
	m := &BangumiMutation{
		config:        c,
		op:            op,
		typ:           TypeBangumi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBangumiID sets the ID field of the mutation.
func withBangumiID(id int) bangumiOption {
	return func(m *BangumiMutation) {
		var (
			err   error
			once  sync.Once
			value *Bangumi
		)
		m.oldValue = func(ctx context.Context) (*Bangumi, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bangumi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBangumi sets the old Bangumi of the mutation.
func withBangumi(node *Bangumi) bangumiOption {
	return func(m *BangumiMutation) {
		m.oldValue = func(context.Context) (*Bangumi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BangumiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BangumiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bangumi entities.
func (m *BangumiMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BangumiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BangumiMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bangumi.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *BangumiMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BangumiMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BangumiMutation) ResetTitle() {
	m.title = nil
}

// SetEnglishTitle sets the "english_title" field.
func (m *BangumiMutation) SetEnglishTitle(s string) {
	m.english_title = &s
}

// EnglishTitle returns the value of the "english_title" field in the mutation.
func (m *BangumiMutation) EnglishTitle() (r string, exists bool) {
	v := m.english_title
	if v == nil {
		return
	}
	return *v, true
}

// OldEnglishTitle returns the old "english_title" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldEnglishTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnglishTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnglishTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnglishTitle: %w", err)
	}
	return oldValue.EnglishTitle, nil
}

// ClearEnglishTitle clears the value of the "english_title" field.
func (m *BangumiMutation) ClearEnglishTitle() {
	m.english_title = nil
	m.clearedFields[bangumi.FieldEnglishTitle] = struct{}{}
}

// EnglishTitleCleared returns if the "english_title" field was cleared in this mutation.
func (m *BangumiMutation) EnglishTitleCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldEnglishTitle]
	return ok
}

// ResetEnglishTitle resets all changes to the "english_title" field.
func (m *BangumiMutation) ResetEnglishTitle() {
	m.english_title = nil
	delete(m.clearedFields, bangumi.FieldEnglishTitle)
}

// SetJapaneseTitle sets the "japanese_title" field.
func (m *BangumiMutation) SetJapaneseTitle(s string) {
	m.japanese_title = &s
}

// JapaneseTitle returns the value of the "japanese_title" field in the mutation.
func (m *BangumiMutation) JapaneseTitle() (r string, exists bool) {
	v := m.japanese_title
	if v == nil {
		return
	}
	return *v, true
}

// OldJapaneseTitle returns the old "japanese_title" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldJapaneseTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJapaneseTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJapaneseTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJapaneseTitle: %w", err)
	}
	return oldValue.JapaneseTitle, nil
}

// ClearJapaneseTitle clears the value of the "japanese_title" field.
func (m *BangumiMutation) ClearJapaneseTitle() {
	m.japanese_title = nil
	m.clearedFields[bangumi.FieldJapaneseTitle] = struct{}{}
}

// JapaneseTitleCleared returns if the "japanese_title" field was cleared in this mutation.
func (m *BangumiMutation) JapaneseTitleCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldJapaneseTitle]
	return ok
}

// ResetJapaneseTitle resets all changes to the "japanese_title" field.
func (m *BangumiMutation) ResetJapaneseTitle() {
	m.japanese_title = nil
	delete(m.clearedFields, bangumi.FieldJapaneseTitle)
}

// SetType sets the "type" field.
func (m *BangumiMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *BangumiMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BangumiMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *BangumiMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BangumiMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BangumiMutation) ResetStatus() {
	m.status = nil
}

// SetScore sets the "score" field.
func (m *BangumiMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *BangumiMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *BangumiMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *BangumiMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *BangumiMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[bangumi.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *BangumiMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *BangumiMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, bangumi.FieldScore)
}

// SetTags sets the "tags" field.
func (m *BangumiMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *BangumiMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *BangumiMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[bangumi.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *BangumiMutation) TagsCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *BangumiMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, bangumi.FieldTags)
}

// SetSynopsis sets the "synopsis" field.
func (m *BangumiMutation) SetSynopsis(s string) {
	m.synopsis = &s
}

// Synopsis returns the value of the "synopsis" field in the mutation.
func (m *BangumiMutation) Synopsis() (r string, exists bool) {
	v := m.synopsis
	if v == nil {
		return
	}
	return *v, true
}

// OldSynopsis returns the old "synopsis" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldSynopsis(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSynopsis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSynopsis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSynopsis: %w", err)
	}
	return oldValue.Synopsis, nil
}

// ClearSynopsis clears the value of the "synopsis" field.
func (m *BangumiMutation) ClearSynopsis() {
	m.synopsis = nil
	m.clearedFields[bangumi.FieldSynopsis] = struct{}{}
}

// SynopsisCleared returns if the "synopsis" field was cleared in this mutation.
func (m *BangumiMutation) SynopsisCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldSynopsis]
	return ok
}

// ResetSynopsis resets all changes to the "synopsis" field.
func (m *BangumiMutation) ResetSynopsis() {
	m.synopsis = nil
	delete(m.clearedFields, bangumi.FieldSynopsis)
}

// SetCoverImage sets the "cover_image" field.
func (m *BangumiMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *BangumiMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *BangumiMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[bangumi.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *BangumiMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *BangumiMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, bangumi.FieldCoverImage)
}

// SetTrailerURL sets the "trailer_url" field.
func (m *BangumiMutation) SetTrailerURL(s string) {
	m.trailer_url = &s
}

// TrailerURL returns the value of the "trailer_url" field in the mutation.
func (m *BangumiMutation) TrailerURL() (r string, exists bool) {
	v := m.trailer_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrailerURL returns the old "trailer_url" field's value of the Bangumi entity.
// If the Bangumi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BangumiMutation) OldTrailerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrailerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrailerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrailerURL: %w", err)
	}
	return oldValue.TrailerURL, nil
}

// ClearTrailerURL clears the value of the "trailer_url" field.
func (m *BangumiMutation) ClearTrailerURL() {
	m.trailer_url = nil
	m.clearedFields[bangumi.FieldTrailerURL] = struct{}{}
}

// TrailerURLCleared returns if the "trailer_url" field was cleared in this mutation.
func (m *BangumiMutation) TrailerURLCleared() bool {
	_, ok := m.clearedFields[bangumi.FieldTrailerURL]
	return ok
}

// ResetTrailerURL resets all changes to the "trailer_url" field.
func (m *BangumiMutation) ResetTrailerURL() {
	m.trailer_url = nil
	delete(m.clearedFields, bangumi.FieldTrailerURL)
}

// AddSeasonIDs adds the "seasons" edge to the Season entity by ids.
func (m *BangumiMutation) AddSeasonIDs(ids ...int) {
	if m.seasons == nil {
		m.seasons = make(map[int]struct{})
	}
	for i := range ids {
		m.seasons[ids[i]] = struct{}{}
	}
}

// ClearSeasons clears the "seasons" edge to the Season entity.
func (m *BangumiMutation) ClearSeasons() {
	m.clearedseasons = true
}

// SeasonsCleared reports if the "seasons" edge to the Season entity was cleared.
func (m *BangumiMutation) SeasonsCleared() bool {
	return m.clearedseasons
}

// RemoveSeasonIDs removes the "seasons" edge to the Season entity by IDs.
func (m *BangumiMutation) RemoveSeasonIDs(ids ...int) {
	if m.removedseasons == nil {
		m.removedseasons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seasons, ids[i])
		m.removedseasons[ids[i]] = struct{}{}
	}
}

// RemovedSeasons returns the removed IDs of the "seasons" edge to the Season entity.
func (m *BangumiMutation) RemovedSeasonsIDs() (ids []int) {
	for id := range m.removedseasons {
		ids = append(ids, id)
	}
	return
}

// SeasonsIDs returns the "seasons" edge IDs in the mutation.
func (m *BangumiMutation) SeasonsIDs() (ids []int) {
	for id := range m.seasons {
		ids = append(ids, id)
	}
	return
}

// ResetSeasons resets all changes to the "seasons" edge.
func (m *BangumiMutation) ResetSeasons() {
	m.seasons = nil
	m.clearedseasons = false
	m.removedseasons = nil
}

// AddCastMemberIDs adds the "cast_members" edge to the CastMember entity by ids.
func (m *BangumiMutation) AddCastMemberIDs(ids ...int) {
	if m.cast_members == nil {
		m.cast_members = make(map[int]struct{})
	}
	for i := range ids {
		m.cast_members[ids[i]] = struct{}{}
	}
}

// ClearCastMembers clears the "cast_members" edge to the CastMember entity.
func (m *BangumiMutation) ClearCastMembers() {
	m.clearedcast_members = true
}

// CastMembersCleared reports if the "cast_members" edge to the CastMember entity was cleared.
func (m *BangumiMutation) CastMembersCleared() bool {
	return m.clearedcast_members
}

// RemoveCastMemberIDs removes the "cast_members" edge to the CastMember entity by IDs.
func (m *BangumiMutation) RemoveCastMemberIDs(ids ...int) {
	if m.removedcast_members == nil {
		m.removedcast_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cast_members, ids[i])
		m.removedcast_members[ids[i]] = struct{}{}
	}
}

// RemovedCastMembers returns the removed IDs of the "cast_members" edge to the CastMember entity.
func (m *BangumiMutation) RemovedCastMembersIDs() (ids []int) {
	for id := range m.removedcast_members {
		ids = append(ids, id)
	}
	return
}

// CastMembersIDs returns the "cast_members" edge IDs in the mutation.
func (m *BangumiMutation) CastMembersIDs() (ids []int) {
	for id := range m.cast_members {
		ids = append(ids, id)
	}
	return
}

// ResetCastMembers resets all changes to the "cast_members" edge.
func (m *BangumiMutation) ResetCastMembers() {
	m.cast_members = nil
	m.clearedcast_members = false
	m.removedcast_members = nil
}

// Where appends a list predicates to the BangumiMutation builder.
func (m *BangumiMutation) Where(ps ...predicate.Bangumi) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BangumiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BangumiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bangumi, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BangumiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BangumiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bangumi).
func (m *BangumiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BangumiMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, bangumi.FieldTitle)
	}
	if m.english_title != nil {
		fields = append(fields, bangumi.FieldEnglishTitle)
	}
	if m.japanese_title != nil {
		fields = append(fields, bangumi.FieldJapaneseTitle)
	}
	if m._type != nil {
		fields = append(fields, bangumi.FieldType)
	}
	if m.status != nil {
		fields = append(fields, bangumi.FieldStatus)
	}
	if m.score != nil {
		fields = append(fields, bangumi.FieldScore)
	}
	if m.tags != nil {
		fields = append(fields, bangumi.FieldTags)
	}
	if m.synopsis != nil {
		fields = append(fields, bangumi.FieldSynopsis)
	}
	if m.cover_image != nil {
		fields = append(fields, bangumi.FieldCoverImage)
	}
	if m.trailer_url != nil {
		fields = append(fields, bangumi.FieldTrailerURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BangumiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bangumi.FieldTitle:
		return m.Title()
	case bangumi.FieldEnglishTitle:
		return m.EnglishTitle()
	case bangumi.FieldJapaneseTitle:
		return m.JapaneseTitle()
	case bangumi.FieldType:
		return m.GetType()
	case bangumi.FieldStatus:
		return m.Status()
	case bangumi.FieldScore:
		return m.Score()
	case bangumi.FieldTags:
		return m.Tags()
	case bangumi.FieldSynopsis:
		return m.Synopsis()
	case bangumi.FieldCoverImage:
		return m.CoverImage()
	case bangumi.FieldTrailerURL:
		return m.TrailerURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BangumiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bangumi.FieldTitle:
		return m.OldTitle(ctx)
	case bangumi.FieldEnglishTitle:
		return m.OldEnglishTitle(ctx)
	case bangumi.FieldJapaneseTitle:
		return m.OldJapaneseTitle(ctx)
	case bangumi.FieldType:
		return m.OldType(ctx)
	case bangumi.FieldStatus:
		return m.OldStatus(ctx)
	case bangumi.FieldScore:
		return m.OldScore(ctx)
	case bangumi.FieldTags:
		return m.OldTags(ctx)
	case bangumi.FieldSynopsis:
		return m.OldSynopsis(ctx)
	case bangumi.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case bangumi.FieldTrailerURL:
		return m.OldTrailerURL(ctx)
	}
	return nil, fmt.Errorf("unknown Bangumi field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BangumiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bangumi.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case bangumi.FieldEnglishTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnglishTitle(v)
		return nil
	case bangumi.FieldJapaneseTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJapaneseTitle(v)
		return nil
	case bangumi.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bangumi.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bangumi.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case bangumi.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case bangumi.FieldSynopsis:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSynopsis(v)
		return nil
	case bangumi.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case bangumi.FieldTrailerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrailerURL(v)
		return nil
	}
	return fmt.Errorf("unknown Bangumi field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BangumiMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, bangumi.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BangumiMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bangumi.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BangumiMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bangumi.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown Bangumi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BangumiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bangumi.FieldEnglishTitle) {
		fields = append(fields, bangumi.FieldEnglishTitle)
	}
	if m.FieldCleared(bangumi.FieldJapaneseTitle) {
		fields = append(fields, bangumi.FieldJapaneseTitle)
	}
	if m.FieldCleared(bangumi.FieldScore) {
		fields = append(fields, bangumi.FieldScore)
	}
	if m.FieldCleared(bangumi.FieldTags) {
		fields = append(fields, bangumi.FieldTags)
	}
	if m.FieldCleared(bangumi.FieldSynopsis) {
		fields = append(fields, bangumi.FieldSynopsis)
	}
	if m.FieldCleared(bangumi.FieldCoverImage) {
		fields = append(fields, bangumi.FieldCoverImage)
	}
	if m.FieldCleared(bangumi.FieldTrailerURL) {
		fields = append(fields, bangumi.FieldTrailerURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BangumiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BangumiMutation) ClearField(name string) error {
	switch name {
	case bangumi.FieldEnglishTitle:
		m.ClearEnglishTitle()
		return nil
	case bangumi.FieldJapaneseTitle:
		m.ClearJapaneseTitle()
		return nil
	case bangumi.FieldScore:
		m.ClearScore()
		return nil
	case bangumi.FieldTags:
		m.ClearTags()
		return nil
	case bangumi.FieldSynopsis:
		m.ClearSynopsis()
		return nil
	case bangumi.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	case bangumi.FieldTrailerURL:
		m.ClearTrailerURL()
		return nil
	}
	return fmt.Errorf("unknown Bangumi nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BangumiMutation) ResetField(name string) error {
	switch name {
	case bangumi.FieldTitle:
		m.ResetTitle()
		return nil
	case bangumi.FieldEnglishTitle:
		m.ResetEnglishTitle()
		return nil
	case bangumi.FieldJapaneseTitle:
		m.ResetJapaneseTitle()
		return nil
	case bangumi.FieldType:
		m.ResetType()
		return nil
	case bangumi.FieldStatus:
		m.ResetStatus()
		return nil
	case bangumi.FieldScore:
		m.ResetScore()
		return nil
	case bangumi.FieldTags:
		m.ResetTags()
		return nil
	case bangumi.FieldSynopsis:
		m.ResetSynopsis()
		return nil
	case bangumi.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case bangumi.FieldTrailerURL:
		m.ResetTrailerURL()
		return nil
	}
	return fmt.Errorf("unknown Bangumi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BangumiMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.seasons != nil {
		edges = append(edges, bangumi.EdgeSeasons)
	}
	if m.cast_members != nil {
		edges = append(edges, bangumi.EdgeCastMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BangumiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bangumi.EdgeSeasons:
		ids := make([]ent.Value, 0, len(m.seasons))
		for id := range m.seasons {
			ids = append(ids, id)
		}
		return ids
	case bangumi.EdgeCastMembers:
		ids := make([]ent.Value, 0, len(m.cast_members))
		for id := range m.cast_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BangumiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedseasons != nil {
		edges = append(edges, bangumi.EdgeSeasons)
	}
	if m.removedcast_members != nil {
		edges = append(edges, bangumi.EdgeCastMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BangumiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bangumi.EdgeSeasons:
		ids := make([]ent.Value, 0, len(m.removedseasons))
		for id := range m.removedseasons {
			ids = append(ids, id)
		}
		return ids
	case bangumi.EdgeCastMembers:
		ids := make([]ent.Value, 0, len(m.removedcast_members))
		for id := range m.removedcast_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BangumiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedseasons {
		edges = append(edges, bangumi.EdgeSeasons)
	}
	if m.clearedcast_members {
		edges = append(edges, bangumi.EdgeCastMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BangumiMutation) EdgeCleared(name string) bool {
	switch name {
	case bangumi.EdgeSeasons:
		return m.clearedseasons
	case bangumi.EdgeCastMembers:
		return m.clearedcast_members
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BangumiMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bangumi unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BangumiMutation) ResetEdge(name string) error {
	switch name {
	case bangumi.EdgeSeasons:
		m.ResetSeasons()
		return nil
	case bangumi.EdgeCastMembers:
		m.ResetCastMembers()
		return nil
	}
	return fmt.Errorf("unknown Bangumi edge %s", name)
}

// CastMemberMutation represents an operation that mutates the CastMember nodes in the graph.
type CastMemberMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	character_name *string
	profile_path   *string
	clearedFields  map[string]struct{}
	season         *int
	clearedseason  bool
	done           bool
	oldValue       func(context.Context) (*CastMember, error)
	predicates     []predicate.CastMember
}

var _ ent.Mutation = (*CastMemberMutation)(nil)

// castmemberOption allows management of the mutation configuration using functional options.
type castmemberOption func(*CastMemberMutation)

// newCastMemberMutation creates new mutation for the CastMember entity.
func newCastMemberMutation(c config, op Op, opts ...castmemberOption) *CastMemberMutation {
	m := &CastMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeCastMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCastMemberID sets the ID field of the mutation.
func withCastMemberID(id int) castmemberOption {
	return func(m *CastMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *CastMember
		)
		m.oldValue = func(ctx context.Context) (*CastMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CastMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCastMember sets the old CastMember of the mutation.
func withCastMember(node *CastMember) castmemberOption {
	return func(m *CastMemberMutation) {
		m.oldValue = func(context.Context) (*CastMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CastMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CastMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CastMember entities.
func (m *CastMemberMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CastMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CastMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CastMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CastMemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CastMemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CastMember entity.
// If the CastMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CastMemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CastMemberMutation) ResetName() {
	m.name = nil
}

// SetCharacterName sets the "character_name" field.
func (m *CastMemberMutation) SetCharacterName(s string) {
	m.character_name = &s
}

// CharacterName returns the value of the "character_name" field in the mutation.
func (m *CastMemberMutation) CharacterName() (r string, exists bool) {
	v := m.character_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCharacterName returns the old "character_name" field's value of the CastMember entity.
// If the CastMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CastMemberMutation) OldCharacterName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharacterName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharacterName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharacterName: %w", err)
	}
	return oldValue.CharacterName, nil
}

// ClearCharacterName clears the value of the "character_name" field.
func (m *CastMemberMutation) ClearCharacterName() {
	m.character_name = nil
	m.clearedFields[castmember.FieldCharacterName] = struct{}{}
}

// CharacterNameCleared returns if the "character_name" field was cleared in this mutation.
func (m *CastMemberMutation) CharacterNameCleared() bool {
	_, ok := m.clearedFields[castmember.FieldCharacterName]
	return ok
}

// ResetCharacterName resets all changes to the "character_name" field.
func (m *CastMemberMutation) ResetCharacterName() {
	m.character_name = nil
	delete(m.clearedFields, castmember.FieldCharacterName)
}

// SetProfilePath sets the "profile_path" field.
func (m *CastMemberMutation) SetProfilePath(s string) {
	m.profile_path = &s
}

// ProfilePath returns the value of the "profile_path" field in the mutation.
func (m *CastMemberMutation) ProfilePath() (r string, exists bool) {
	v := m.profile_path
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePath returns the old "profile_path" field's value of the CastMember entity.
// If the CastMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CastMemberMutation) OldProfilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePath: %w", err)
	}
	return oldValue.ProfilePath, nil
}

// ClearProfilePath clears the value of the "profile_path" field.
func (m *CastMemberMutation) ClearProfilePath() {
	m.profile_path = nil
	m.clearedFields[castmember.FieldProfilePath] = struct{}{}
}

// ProfilePathCleared returns if the "profile_path" field was cleared in this mutation.
func (m *CastMemberMutation) ProfilePathCleared() bool {
	_, ok := m.clearedFields[castmember.FieldProfilePath]
	return ok
}

// ResetProfilePath resets all changes to the "profile_path" field.
func (m *CastMemberMutation) ResetProfilePath() {
	m.profile_path = nil
	delete(m.clearedFields, castmember.FieldProfilePath)
}

// SetSeasonID sets the "season_id" field.
func (m *CastMemberMutation) SetSeasonID(i int) {
	m.season = &i
}

// SeasonID returns the value of the "season_id" field in the mutation.
func (m *CastMemberMutation) SeasonID() (r int, exists bool) {
	v := m.season
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonID returns the old "season_id" field's value of the CastMember entity.
// If the CastMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CastMemberMutation) OldSeasonID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonID: %w", err)
	}
	return oldValue.SeasonID, nil
}

// ClearSeasonID clears the value of the "season_id" field.
func (m *CastMemberMutation) ClearSeasonID() {
	m.season = nil
	m.clearedFields[castmember.FieldSeasonID] = struct{}{}
}

// SeasonIDCleared returns if the "season_id" field was cleared in this mutation.
func (m *CastMemberMutation) SeasonIDCleared() bool {
	_, ok := m.clearedFields[castmember.FieldSeasonID]
	return ok
}

// ResetSeasonID resets all changes to the "season_id" field.
func (m *CastMemberMutation) ResetSeasonID() {
	m.season = nil
	delete(m.clearedFields, castmember.FieldSeasonID)
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *CastMemberMutation) ClearSeason() {
	m.clearedseason = true
	m.clearedFields[castmember.FieldSeasonID] = struct{}{}
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *CastMemberMutation) SeasonCleared() bool {
	return m.SeasonIDCleared() || m.clearedseason
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *CastMemberMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *CastMemberMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// Where appends a list predicates to the CastMemberMutation builder.
func (m *CastMemberMutation) Where(ps ...predicate.CastMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CastMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CastMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CastMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CastMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CastMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CastMember).
func (m *CastMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CastMemberMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, castmember.FieldName)
	}
	if m.character_name != nil {
		fields = append(fields, castmember.FieldCharacterName)
	}
	if m.profile_path != nil {
		fields = append(fields, castmember.FieldProfilePath)
	}
	if m.season != nil {
		fields = append(fields, castmember.FieldSeasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CastMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case castmember.FieldName:
		return m.Name()
	case castmember.FieldCharacterName:
		return m.CharacterName()
	case castmember.FieldProfilePath:
		return m.ProfilePath()
	case castmember.FieldSeasonID:
		return m.SeasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CastMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case castmember.FieldName:
		return m.OldName(ctx)
	case castmember.FieldCharacterName:
		return m.OldCharacterName(ctx)
	case castmember.FieldProfilePath:
		return m.OldProfilePath(ctx)
	case castmember.FieldSeasonID:
		return m.OldSeasonID(ctx)
	}
	return nil, fmt.Errorf("unknown CastMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CastMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case castmember.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case castmember.FieldCharacterName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterName(v)
		return nil
	case castmember.FieldProfilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePath(v)
		return nil
	case castmember.FieldSeasonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonID(v)
		return nil
	}
	return fmt.Errorf("unknown CastMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CastMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CastMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CastMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CastMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CastMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(castmember.FieldCharacterName) {
		fields = append(fields, castmember.FieldCharacterName)
	}
	if m.FieldCleared(castmember.FieldProfilePath) {
		fields = append(fields, castmember.FieldProfilePath)
	}
	if m.FieldCleared(castmember.FieldSeasonID) {
		fields = append(fields, castmember.FieldSeasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CastMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CastMemberMutation) ClearField(name string) error {
	switch name {
	case castmember.FieldCharacterName:
		m.ClearCharacterName()
		return nil
	case castmember.FieldProfilePath:
		m.ClearProfilePath()
		return nil
	case castmember.FieldSeasonID:
		m.ClearSeasonID()
		return nil
	}
	return fmt.Errorf("unknown CastMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CastMemberMutation) ResetField(name string) error {
	switch name {
	case castmember.FieldName:
		m.ResetName()
		return nil
	case castmember.FieldCharacterName:
		m.ResetCharacterName()
		return nil
	case castmember.FieldProfilePath:
		m.ResetProfilePath()
		return nil
	case castmember.FieldSeasonID:
		m.ResetSeasonID()
		return nil
	}
	return fmt.Errorf("unknown CastMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CastMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.season != nil {
		edges = append(edges, castmember.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CastMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case castmember.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CastMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CastMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CastMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedseason {
		edges = append(edges, castmember.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CastMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case castmember.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CastMemberMutation) ClearEdge(name string) error {
	switch name {
	case castmember.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown CastMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CastMemberMutation) ResetEdge(name string) error {
	switch name {
	case castmember.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown CastMember edge %s", name)
}

// EpisodeMutation represents an operation that mutates the Episode nodes in the graph.
type EpisodeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	episode_number      *int
	addepisode_number   *int
	title               *string
	overview            *string
	air_date            *time.Time
	clearedFields       map[string]struct{}
	season              *int
	clearedseason       bool
	cast_members        map[int]struct{}
	removedcast_members map[int]struct{}
	clearedcast_members bool
	done                bool
	oldValue            func(context.Context) (*Episode, error)
	predicates          []predicate.Episode
}

var _ ent.Mutation = (*EpisodeMutation)(nil)

// episodeOption allows management of the mutation configuration using functional options.
type episodeOption func(*EpisodeMutation)

// newEpisodeMutation creates new mutation for the Episode entity.
func newEpisodeMutation(c config, op Op, opts ...episodeOption) *EpisodeMutation {
	m := &EpisodeMutation{
		config:        c,
		op:            op,
		typ:           TypeEpisode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpisodeID sets the ID field of the mutation.
func withEpisodeID(id int) episodeOption {
	return func(m *EpisodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Episode
		)
		m.oldValue = func(ctx context.Context) (*Episode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Episode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpisode sets the old Episode of the mutation.
func withEpisode(node *Episode) episodeOption {
	return func(m *EpisodeMutation) {
		m.oldValue = func(context.Context) (*Episode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpisodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpisodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Episode entities.
func (m *EpisodeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EpisodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EpisodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Episode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEpisodeNumber sets the "episode_number" field.
func (m *EpisodeMutation) SetEpisodeNumber(i int) {
	m.episode_number = &i
	m.addepisode_number = nil
}

// EpisodeNumber returns the value of the "episode_number" field in the mutation.
func (m *EpisodeMutation) EpisodeNumber() (r int, exists bool) {
	v := m.episode_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeNumber returns the old "episode_number" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldEpisodeNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeNumber: %w", err)
	}
	return oldValue.EpisodeNumber, nil
}

// AddEpisodeNumber adds i to the "episode_number" field.
func (m *EpisodeMutation) AddEpisodeNumber(i int) {
	if m.addepisode_number != nil {
		*m.addepisode_number += i
	} else {
		m.addepisode_number = &i
	}
}

// AddedEpisodeNumber returns the value that was added to the "episode_number" field in this mutation.
func (m *EpisodeMutation) AddedEpisodeNumber() (r int, exists bool) {
	v := m.addepisode_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeNumber resets all changes to the "episode_number" field.
func (m *EpisodeMutation) ResetEpisodeNumber() {
	m.episode_number = nil
	m.addepisode_number = nil
}

// SetTitle sets the "title" field.
func (m *EpisodeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EpisodeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EpisodeMutation) ResetTitle() {
	m.title = nil
}

// SetOverview sets the "overview" field.
func (m *EpisodeMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *EpisodeMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ClearOverview clears the value of the "overview" field.
func (m *EpisodeMutation) ClearOverview() {
	m.overview = nil
	m.clearedFields[episode.FieldOverview] = struct{}{}
}

// OverviewCleared returns if the "overview" field was cleared in this mutation.
func (m *EpisodeMutation) OverviewCleared() bool {
	_, ok := m.clearedFields[episode.FieldOverview]
	return ok
}

// ResetOverview resets all changes to the "overview" field.
func (m *EpisodeMutation) ResetOverview() {
	m.overview = nil
	delete(m.clearedFields, episode.FieldOverview)
}

// SetAirDate sets the "air_date" field.
func (m *EpisodeMutation) SetAirDate(t time.Time) {
	m.air_date = &t
}

// AirDate returns the value of the "air_date" field in the mutation.
func (m *EpisodeMutation) AirDate() (r time.Time, exists bool) {
	v := m.air_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAirDate returns the old "air_date" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldAirDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirDate: %w", err)
	}
	return oldValue.AirDate, nil
}

// ClearAirDate clears the value of the "air_date" field.
func (m *EpisodeMutation) ClearAirDate() {
	m.air_date = nil
	m.clearedFields[episode.FieldAirDate] = struct{}{}
}

// AirDateCleared returns if the "air_date" field was cleared in this mutation.
func (m *EpisodeMutation) AirDateCleared() bool {
	_, ok := m.clearedFields[episode.FieldAirDate]
	return ok
}

// ResetAirDate resets all changes to the "air_date" field.
func (m *EpisodeMutation) ResetAirDate() {
	m.air_date = nil
	delete(m.clearedFields, episode.FieldAirDate)
}

// SetSeasonID sets the "season_id" field.
func (m *EpisodeMutation) SetSeasonID(i int) {
	m.season = &i
}

// SeasonID returns the value of the "season_id" field in the mutation.
func (m *EpisodeMutation) SeasonID() (r int, exists bool) {
	v := m.season
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonID returns the old "season_id" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldSeasonID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonID: %w", err)
	}
	return oldValue.SeasonID, nil
}

// ClearSeasonID clears the value of the "season_id" field.
func (m *EpisodeMutation) ClearSeasonID() {
	m.season = nil
	m.clearedFields[episode.FieldSeasonID] = struct{}{}
}

// SeasonIDCleared returns if the "season_id" field was cleared in this mutation.
func (m *EpisodeMutation) SeasonIDCleared() bool {
	_, ok := m.clearedFields[episode.FieldSeasonID]
	return ok
}

// ResetSeasonID resets all changes to the "season_id" field.
func (m *EpisodeMutation) ResetSeasonID() {
	m.season = nil
	delete(m.clearedFields, episode.FieldSeasonID)
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *EpisodeMutation) ClearSeason() {
	m.clearedseason = true
	m.clearedFields[episode.FieldSeasonID] = struct{}{}
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *EpisodeMutation) SeasonCleared() bool {
	return m.SeasonIDCleared() || m.clearedseason
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *EpisodeMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *EpisodeMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// AddCastMemberIDs adds the "cast_members" edge to the CastMember entity by ids.
func (m *EpisodeMutation) AddCastMemberIDs(ids ...int) {
	if m.cast_members == nil {
		m.cast_members = make(map[int]struct{})
	}
	for i := range ids {
		m.cast_members[ids[i]] = struct{}{}
	}
}

// ClearCastMembers clears the "cast_members" edge to the CastMember entity.
func (m *EpisodeMutation) ClearCastMembers() {
	m.clearedcast_members = true
}

// CastMembersCleared reports if the "cast_members" edge to the CastMember entity was cleared.
func (m *EpisodeMutation) CastMembersCleared() bool {
	return m.clearedcast_members
}

// RemoveCastMemberIDs removes the "cast_members" edge to the CastMember entity by IDs.
func (m *EpisodeMutation) RemoveCastMemberIDs(ids ...int) {
	if m.removedcast_members == nil {
		m.removedcast_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cast_members, ids[i])
		m.removedcast_members[ids[i]] = struct{}{}
	}
}

// RemovedCastMembers returns the removed IDs of the "cast_members" edge to the CastMember entity.
func (m *EpisodeMutation) RemovedCastMembersIDs() (ids []int) {
	for id := range m.removedcast_members {
		ids = append(ids, id)
	}
	return
}

// CastMembersIDs returns the "cast_members" edge IDs in the mutation.
func (m *EpisodeMutation) CastMembersIDs() (ids []int) {
	for id := range m.cast_members {
		ids = append(ids, id)
	}
	return
}

// ResetCastMembers resets all changes to the "cast_members" edge.
func (m *EpisodeMutation) ResetCastMembers() {
	m.cast_members = nil
	m.clearedcast_members = false
	m.removedcast_members = nil
}

// Where appends a list predicates to the EpisodeMutation builder.
func (m *EpisodeMutation) Where(ps ...predicate.Episode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EpisodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EpisodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Episode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EpisodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EpisodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Episode).
func (m *EpisodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EpisodeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.episode_number != nil {
		fields = append(fields, episode.FieldEpisodeNumber)
	}
	if m.title != nil {
		fields = append(fields, episode.FieldTitle)
	}
	if m.overview != nil {
		fields = append(fields, episode.FieldOverview)
	}
	if m.air_date != nil {
		fields = append(fields, episode.FieldAirDate)
	}
	if m.season != nil {
		fields = append(fields, episode.FieldSeasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EpisodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldEpisodeNumber:
		return m.EpisodeNumber()
	case episode.FieldTitle:
		return m.Title()
	case episode.FieldOverview:
		return m.Overview()
	case episode.FieldAirDate:
		return m.AirDate()
	case episode.FieldSeasonID:
		return m.SeasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EpisodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case episode.FieldEpisodeNumber:
		return m.OldEpisodeNumber(ctx)
	case episode.FieldTitle:
		return m.OldTitle(ctx)
	case episode.FieldOverview:
		return m.OldOverview(ctx)
	case episode.FieldAirDate:
		return m.OldAirDate(ctx)
	case episode.FieldSeasonID:
		return m.OldSeasonID(ctx)
	}
	return nil, fmt.Errorf("unknown Episode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case episode.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeNumber(v)
		return nil
	case episode.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case episode.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case episode.FieldAirDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirDate(v)
		return nil
	case episode.FieldSeasonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonID(v)
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EpisodeMutation) AddedFields() []string {
	var fields []string
	if m.addepisode_number != nil {
		fields = append(fields, episode.FieldEpisodeNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EpisodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldEpisodeNumber:
		return m.AddedEpisodeNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case episode.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Episode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EpisodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(episode.FieldOverview) {
		fields = append(fields, episode.FieldOverview)
	}
	if m.FieldCleared(episode.FieldAirDate) {
		fields = append(fields, episode.FieldAirDate)
	}
	if m.FieldCleared(episode.FieldSeasonID) {
		fields = append(fields, episode.FieldSeasonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EpisodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpisodeMutation) ClearField(name string) error {
	switch name {
	case episode.FieldOverview:
		m.ClearOverview()
		return nil
	case episode.FieldAirDate:
		m.ClearAirDate()
		return nil
	case episode.FieldSeasonID:
		m.ClearSeasonID()
		return nil
	}
	return fmt.Errorf("unknown Episode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EpisodeMutation) ResetField(name string) error {
	switch name {
	case episode.FieldEpisodeNumber:
		m.ResetEpisodeNumber()
		return nil
	case episode.FieldTitle:
		m.ResetTitle()
		return nil
	case episode.FieldOverview:
		m.ResetOverview()
		return nil
	case episode.FieldAirDate:
		m.ResetAirDate()
		return nil
	case episode.FieldSeasonID:
		m.ResetSeasonID()
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EpisodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.season != nil {
		edges = append(edges, episode.EdgeSeason)
	}
	if m.cast_members != nil {
		edges = append(edges, episode.EdgeCastMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EpisodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case episode.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	case episode.EdgeCastMembers:
		ids := make([]ent.Value, 0, len(m.cast_members))
		for id := range m.cast_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EpisodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcast_members != nil {
		edges = append(edges, episode.EdgeCastMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EpisodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case episode.EdgeCastMembers:
		ids := make([]ent.Value, 0, len(m.removedcast_members))
		for id := range m.removedcast_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EpisodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedseason {
		edges = append(edges, episode.EdgeSeason)
	}
	if m.clearedcast_members {
		edges = append(edges, episode.EdgeCastMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EpisodeMutation) EdgeCleared(name string) bool {
	switch name {
	case episode.EdgeSeason:
		return m.clearedseason
	case episode.EdgeCastMembers:
		return m.clearedcast_members
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EpisodeMutation) ClearEdge(name string) error {
	switch name {
	case episode.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown Episode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EpisodeMutation) ResetEdge(name string) error {
	switch name {
	case episode.EdgeSeason:
		m.ResetSeason()
		return nil
	case episode.EdgeCastMembers:
		m.ResetCastMembers()
		return nil
	}
	return fmt.Errorf("unknown Episode edge %s", name)
}

// SeasonMutation represents an operation that mutates the Season nodes in the graph.
type SeasonMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	season_number       *int
	addseason_number    *int
	air_date            *time.Time
	episode_count       *int
	addepisode_count    *int
	clearedFields       map[string]struct{}
	bangumi             *int
	clearedbangumi      bool
	episodes            map[int]struct{}
	removedepisodes     map[int]struct{}
	clearedepisodes     bool
	cast_members        map[int]struct{}
	removedcast_members map[int]struct{}
	clearedcast_members bool
	done                bool
	oldValue            func(context.Context) (*Season, error)
	predicates          []predicate.Season
}

var _ ent.Mutation = (*SeasonMutation)(nil)

// seasonOption allows management of the mutation configuration using functional options.
type seasonOption func(*SeasonMutation)

// newSeasonMutation creates new mutation for the Season entity.
func newSeasonMutation(c config, op Op, opts ...seasonOption) *SeasonMutation {
	m := &SeasonMutation{
		config:        c,
		op:            op,
		typ:           TypeSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeasonID sets the ID field of the mutation.
func withSeasonID(id int) seasonOption {
	return func(m *SeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *Season
		)
		m.oldValue = func(ctx context.Context) (*Season, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Season.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeason sets the old Season of the mutation.
func withSeason(node *Season) seasonOption {
	return func(m *SeasonMutation) {
		m.oldValue = func(context.Context) (*Season, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Season entities.
func (m *SeasonMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Season.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeasonNumber sets the "season_number" field.
func (m *SeasonMutation) SetSeasonNumber(i int) {
	m.season_number = &i
	m.addseason_number = nil
}

// SeasonNumber returns the value of the "season_number" field in the mutation.
func (m *SeasonMutation) SeasonNumber() (r int, exists bool) {
	v := m.season_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonNumber returns the old "season_number" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSeasonNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonNumber: %w", err)
	}
	return oldValue.SeasonNumber, nil
}

// AddSeasonNumber adds i to the "season_number" field.
func (m *SeasonMutation) AddSeasonNumber(i int) {
	if m.addseason_number != nil {
		*m.addseason_number += i
	} else {
		m.addseason_number = &i
	}
}

// AddedSeasonNumber returns the value that was added to the "season_number" field in this mutation.
func (m *SeasonMutation) AddedSeasonNumber() (r int, exists bool) {
	v := m.addseason_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeasonNumber resets all changes to the "season_number" field.
func (m *SeasonMutation) ResetSeasonNumber() {
	m.season_number = nil
	m.addseason_number = nil
}

// SetAirDate sets the "air_date" field.
func (m *SeasonMutation) SetAirDate(t time.Time) {
	m.air_date = &t
}

// AirDate returns the value of the "air_date" field in the mutation.
func (m *SeasonMutation) AirDate() (r time.Time, exists bool) {
	v := m.air_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAirDate returns the old "air_date" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldAirDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirDate: %w", err)
	}
	return oldValue.AirDate, nil
}

// ClearAirDate clears the value of the "air_date" field.
func (m *SeasonMutation) ClearAirDate() {
	m.air_date = nil
	m.clearedFields[season.FieldAirDate] = struct{}{}
}

// AirDateCleared returns if the "air_date" field was cleared in this mutation.
func (m *SeasonMutation) AirDateCleared() bool {
	_, ok := m.clearedFields[season.FieldAirDate]
	return ok
}

// ResetAirDate resets all changes to the "air_date" field.
func (m *SeasonMutation) ResetAirDate() {
	m.air_date = nil
	delete(m.clearedFields, season.FieldAirDate)
}

// SetEpisodeCount sets the "episode_count" field.
func (m *SeasonMutation) SetEpisodeCount(i int) {
	m.episode_count = &i
	m.addepisode_count = nil
}

// EpisodeCount returns the value of the "episode_count" field in the mutation.
func (m *SeasonMutation) EpisodeCount() (r int, exists bool) {
	v := m.episode_count
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeCount returns the old "episode_count" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldEpisodeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeCount: %w", err)
	}
	return oldValue.EpisodeCount, nil
}

// AddEpisodeCount adds i to the "episode_count" field.
func (m *SeasonMutation) AddEpisodeCount(i int) {
	if m.addepisode_count != nil {
		*m.addepisode_count += i
	} else {
		m.addepisode_count = &i
	}
}

// AddedEpisodeCount returns the value that was added to the "episode_count" field in this mutation.
func (m *SeasonMutation) AddedEpisodeCount() (r int, exists bool) {
	v := m.addepisode_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeCount resets all changes to the "episode_count" field.
func (m *SeasonMutation) ResetEpisodeCount() {
	m.episode_count = nil
	m.addepisode_count = nil
}

// SetBangumiID sets the "bangumi_id" field.
func (m *SeasonMutation) SetBangumiID(i int) {
	m.bangumi = &i
}

// BangumiID returns the value of the "bangumi_id" field in the mutation.
func (m *SeasonMutation) BangumiID() (r int, exists bool) {
	v := m.bangumi
	if v == nil {
		return
	}
	return *v, true
}

// OldBangumiID returns the old "bangumi_id" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldBangumiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBangumiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBangumiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBangumiID: %w", err)
	}
	return oldValue.BangumiID, nil
}

// ClearBangumiID clears the value of the "bangumi_id" field.
func (m *SeasonMutation) ClearBangumiID() {
	m.bangumi = nil
	m.clearedFields[season.FieldBangumiID] = struct{}{}
}

// BangumiIDCleared returns if the "bangumi_id" field was cleared in this mutation.
func (m *SeasonMutation) BangumiIDCleared() bool {
	_, ok := m.clearedFields[season.FieldBangumiID]
	return ok
}

// ResetBangumiID resets all changes to the "bangumi_id" field.
func (m *SeasonMutation) ResetBangumiID() {
	m.bangumi = nil
	delete(m.clearedFields, season.FieldBangumiID)
}

// ClearBangumi clears the "bangumi" edge to the Bangumi entity.
func (m *SeasonMutation) ClearBangumi() {
	m.clearedbangumi = true
	m.clearedFields[season.FieldBangumiID] = struct{}{}
}

// BangumiCleared reports if the "bangumi" edge to the Bangumi entity was cleared.
func (m *SeasonMutation) BangumiCleared() bool {
	return m.BangumiIDCleared() || m.clearedbangumi
}

// BangumiIDs returns the "bangumi" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BangumiID instead. It exists only for internal usage by the builders.
func (m *SeasonMutation) BangumiIDs() (ids []int) {
	if id := m.bangumi; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBangumi resets all changes to the "bangumi" edge.
func (m *SeasonMutation) ResetBangumi() {
	m.bangumi = nil
	m.clearedbangumi = false
}

// AddEpisodeIDs adds the "episodes" edge to the Episode entity by ids.
func (m *SeasonMutation) AddEpisodeIDs(ids ...int) {
	if m.episodes == nil {
		m.episodes = make(map[int]struct{})
	}
	for i := range ids {
		m.episodes[ids[i]] = struct{}{}
	}
}

// ClearEpisodes clears the "episodes" edge to the Episode entity.
func (m *SeasonMutation) ClearEpisodes() {
	m.clearedepisodes = true
}

// EpisodesCleared reports if the "episodes" edge to the Episode entity was cleared.
func (m *SeasonMutation) EpisodesCleared() bool {
	return m.clearedepisodes
}

// RemoveEpisodeIDs removes the "episodes" edge to the Episode entity by IDs.
func (m *SeasonMutation) RemoveEpisodeIDs(ids ...int) {
	if m.removedepisodes == nil {
		m.removedepisodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.episodes, ids[i])
		m.removedepisodes[ids[i]] = struct{}{}
	}
}

// RemovedEpisodes returns the removed IDs of the "episodes" edge to the Episode entity.
func (m *SeasonMutation) RemovedEpisodesIDs() (ids []int) {
	for id := range m.removedepisodes {
		ids = append(ids, id)
	}
	return
}

// EpisodesIDs returns the "episodes" edge IDs in the mutation.
func (m *SeasonMutation) EpisodesIDs() (ids []int) {
	for id := range m.episodes {
		ids = append(ids, id)
	}
	return
}

// ResetEpisodes resets all changes to the "episodes" edge.
func (m *SeasonMutation) ResetEpisodes() {
	m.episodes = nil
	m.clearedepisodes = false
	m.removedepisodes = nil
}

// AddCastMemberIDs adds the "cast_members" edge to the CastMember entity by ids.
func (m *SeasonMutation) AddCastMemberIDs(ids ...int) {
	if m.cast_members == nil {
		m.cast_members = make(map[int]struct{})
	}
	for i := range ids {
		m.cast_members[ids[i]] = struct{}{}
	}
}

// ClearCastMembers clears the "cast_members" edge to the CastMember entity.
func (m *SeasonMutation) ClearCastMembers() {
	m.clearedcast_members = true
}

// CastMembersCleared reports if the "cast_members" edge to the CastMember entity was cleared.
func (m *SeasonMutation) CastMembersCleared() bool {
	return m.clearedcast_members
}

// RemoveCastMemberIDs removes the "cast_members" edge to the CastMember entity by IDs.
func (m *SeasonMutation) RemoveCastMemberIDs(ids ...int) {
	if m.removedcast_members == nil {
		m.removedcast_members = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cast_members, ids[i])
		m.removedcast_members[ids[i]] = struct{}{}
	}
}

// RemovedCastMembers returns the removed IDs of the "cast_members" edge to the CastMember entity.
func (m *SeasonMutation) RemovedCastMembersIDs() (ids []int) {
	for id := range m.removedcast_members {
		ids = append(ids, id)
	}
	return
}

// CastMembersIDs returns the "cast_members" edge IDs in the mutation.
func (m *SeasonMutation) CastMembersIDs() (ids []int) {
	for id := range m.cast_members {
		ids = append(ids, id)
	}
	return
}

// ResetCastMembers resets all changes to the "cast_members" edge.
func (m *SeasonMutation) ResetCastMembers() {
	m.cast_members = nil
	m.clearedcast_members = false
	m.removedcast_members = nil
}

// Where appends a list predicates to the SeasonMutation builder.
func (m *SeasonMutation) Where(ps ...predicate.Season) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Season, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Season).
func (m *SeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeasonMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.season_number != nil {
		fields = append(fields, season.FieldSeasonNumber)
	}
	if m.air_date != nil {
		fields = append(fields, season.FieldAirDate)
	}
	if m.episode_count != nil {
		fields = append(fields, season.FieldEpisodeCount)
	}
	if m.bangumi != nil {
		fields = append(fields, season.FieldBangumiID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case season.FieldSeasonNumber:
		return m.SeasonNumber()
	case season.FieldAirDate:
		return m.AirDate()
	case season.FieldEpisodeCount:
		return m.EpisodeCount()
	case season.FieldBangumiID:
		return m.BangumiID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case season.FieldSeasonNumber:
		return m.OldSeasonNumber(ctx)
	case season.FieldAirDate:
		return m.OldAirDate(ctx)
	case season.FieldEpisodeCount:
		return m.OldEpisodeCount(ctx)
	case season.FieldBangumiID:
		return m.OldBangumiID(ctx)
	}
	return nil, fmt.Errorf("unknown Season field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case season.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonNumber(v)
		return nil
	case season.FieldAirDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirDate(v)
		return nil
	case season.FieldEpisodeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeCount(v)
		return nil
	case season.FieldBangumiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBangumiID(v)
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeasonMutation) AddedFields() []string {
	var fields []string
	if m.addseason_number != nil {
		fields = append(fields, season.FieldSeasonNumber)
	}
	if m.addepisode_count != nil {
		fields = append(fields, season.FieldEpisodeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case season.FieldSeasonNumber:
		return m.AddedSeasonNumber()
	case season.FieldEpisodeCount:
		return m.AddedEpisodeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case season.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeasonNumber(v)
		return nil
	case season.FieldEpisodeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Season numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeasonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(season.FieldAirDate) {
		fields = append(fields, season.FieldAirDate)
	}
	if m.FieldCleared(season.FieldBangumiID) {
		fields = append(fields, season.FieldBangumiID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeasonMutation) ClearField(name string) error {
	switch name {
	case season.FieldAirDate:
		m.ClearAirDate()
		return nil
	case season.FieldBangumiID:
		m.ClearBangumiID()
		return nil
	}
	return fmt.Errorf("unknown Season nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeasonMutation) ResetField(name string) error {
	switch name {
	case season.FieldSeasonNumber:
		m.ResetSeasonNumber()
		return nil
	case season.FieldAirDate:
		m.ResetAirDate()
		return nil
	case season.FieldEpisodeCount:
		m.ResetEpisodeCount()
		return nil
	case season.FieldBangumiID:
		m.ResetBangumiID()
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.bangumi != nil {
		edges = append(edges, season.EdgeBangumi)
	}
	if m.episodes != nil {
		edges = append(edges, season.EdgeEpisodes)
	}
	if m.cast_members != nil {
		edges = append(edges, season.EdgeCastMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeBangumi:
		if id := m.bangumi; id != nil {
			return []ent.Value{*id}
		}
	case season.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.episodes))
		for id := range m.episodes {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeCastMembers:
		ids := make([]ent.Value, 0, len(m.cast_members))
		for id := range m.cast_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedepisodes != nil {
		edges = append(edges, season.EdgeEpisodes)
	}
	if m.removedcast_members != nil {
		edges = append(edges, season.EdgeCastMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.removedepisodes))
		for id := range m.removedepisodes {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeCastMembers:
		ids := make([]ent.Value, 0, len(m.removedcast_members))
		for id := range m.removedcast_members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbangumi {
		edges = append(edges, season.EdgeBangumi)
	}
	if m.clearedepisodes {
		edges = append(edges, season.EdgeEpisodes)
	}
	if m.clearedcast_members {
		edges = append(edges, season.EdgeCastMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case season.EdgeBangumi:
		return m.clearedbangumi
	case season.EdgeEpisodes:
		return m.clearedepisodes
	case season.EdgeCastMembers:
		return m.clearedcast_members
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeasonMutation) ClearEdge(name string) error {
	switch name {
	case season.EdgeBangumi:
		m.ClearBangumi()
		return nil
	}
	return fmt.Errorf("unknown Season unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeasonMutation) ResetEdge(name string) error {
	switch name {
	case season.EdgeBangumi:
		m.ResetBangumi()
		return nil
	case season.EdgeEpisodes:
		m.ResetEpisodes()
		return nil
	case season.EdgeCastMembers:
		m.ResetCastMembers()
		return nil
	}
	return fmt.Errorf("unknown Season edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
